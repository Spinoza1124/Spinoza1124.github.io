<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Makefile教程</title>
    <url>/2025/04/08/Makefile-tutorial/</url>
    <content><![CDATA[<p>Makefile是一个自动化构建工具，通常用于编译和链接程序。它通过定义规则和依赖关系来自动化构建过程，从而简化了软件开发中的重复性任务。<br>Makefile的基本结构包括目标、依赖和命令。目标是要生成的文件，依赖是生成目标所需的文件，命令是在生成目标时执行的操作。</p>
<span id="more"></span>

<h4 id="如何运行示例"><a href="#如何运行示例" class="headerlink" title="如何运行示例"></a>如何运行示例</h4><p>首先安装make终端。对于Linux和MacOS，通常已经预装了make。对于Windows用户，可以使用WSL（Windows Subsystem for Linux）或安装GNU Make。<br>在终端中，进入到包含Makefile的目录，然后运行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>
<p>这将根据Makefile中的规则自动执行构建过程。<br>如果要运行特定的目标，可以在命令后指定目标名称，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make clean</span><br></pre></td></tr></table></figure>
<p>这将执行Makefile中定义的<code>clean</code>目标，通常用于清理生成的文件。</p>
<h4 id="Makefile示例"><a href="#Makefile示例" class="headerlink" title="Makefile示例"></a>Makefile示例</h4><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Makefile示例</span></span><br><span class="line">CC = gcc</span><br><span class="line">CFLAGS = -Wall -g</span><br><span class="line">LDFLAGS = -lm</span><br><span class="line">SOURCES = main.c utils.c</span><br><span class="line">OBJECTS = $(SOURCES:.c=.o)</span><br><span class="line">TARGET = my_program</span><br><span class="line"><span class="comment"># 默认目标</span></span><br><span class="line"><span class="section">all: <span class="variable">$(TARGET)</span></span></span><br><span class="line"><span class="comment"># 目标规则</span></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJECTS)</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(LDFLAGS)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"><span class="comment"># 依赖规则</span></span><br><span class="line"><span class="section">%.o: %.c</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="comment"># 清理目标</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -f <span class="variable">$(OBJECTS)</span> <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure>
<h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><ul>
<li><code>CC</code>：指定编译器，这里使用gcc。</li>
<li><code>CFLAGS</code>：编译选项，这里启用所有警告并生成调试信息。</li>
<li><code>LDFLAGS</code>：链接选项，这里链接数学库。</li>
<li><code>SOURCES</code>：源文件列表。</li>
<li><code>OBJECTS</code>：目标文件列表，通过将源文件扩展名从.c更改为.o来生成。</li>
<li><code>TARGET</code>：最终生成的可执行文件名称。</li>
<li><code>all</code>：默认目标，当运行<code>make</code>时执行。</li>
<li><code>$(TARGET)</code>：依赖于所有目标文件，使用<code>$@</code>表示目标名称，<code>$^</code>表示所有依赖文件。</li>
<li><code>%.o: %.c</code>：模式规则，表示如何从源文件生成目标文件。</li>
<li><code>clean</code>：清理目标，删除所有生成的文件。</li>
</ul>
<h1 id="根据上面的Makefile，举一个实际的例子"><a href="#根据上面的Makefile，举一个实际的例子" class="headerlink" title="根据上面的Makefile，举一个实际的例子"></a>根据上面的Makefile，举一个实际的例子</h1><p>假设我们有两个C源文件<code>main.c</code>和<code>utils.c</code>，以及一个头文件<code>utils.h</code>。我们希望编译这些文件并生成一个名为<code>my_program</code>的可执行文件。<br><code>main.c</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utils.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, World!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>utils.c</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utils.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_message</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This is a message from utils.c\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>utils.h</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> UTILS_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UTILS_H</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_message</span><span class="params">()</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>在终端中，进入到包含这些文件的目录，然后运行<code>make</code>命令。Makefile将自动编译<code>main.c</code>和<code>utils.c</code>，并生成一个名为<code>my_program</code>的可执行文件。<br>运行<code>./my_program</code>将输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hello, World!</span><br><span class="line">This is a message from utils.c</span><br></pre></td></tr></table></figure>

<h4 id="新手示例"><a href="#新手示例" class="headerlink" title="新手示例"></a>新手示例</h4><p>下面的Makefile有3个分离的规则（rules）。当在终端运行<code>make blah</code>时，它会通过一系列的步骤构建一个名为<code>blah</code>的的程序:</p>
<ul>
<li><code>blan</code>给<code>make</code>提供了构建目标(target)的名称, 所以它会在makefile中优先被<code>make</code>程序搜索</li>
<li>构建系统发现<code>blan</code>依赖<code>blah.o</code>,所以<code>make</code>开始搜索<code>blah.o</code>这个目标</li>
<li><code>blah.o</code>没有依赖,直接运行<code>echo</code>命令</li>
<li>接着运行<code>cc -c</code>命令，以为<code>blah.o</code>的依赖的所有<code>commands</code>都执行完了</li>
<li>同理,接着运行顶部的<code>cc</code>命令</li>
<li>就这样,一个编译好的C程序<code>blah</code>就诞生了</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">blah: blah.o</span></span><br><span class="line">    cc -o blah blah.o <span class="comment"># Runs third</span></span><br><span class="line"></span><br><span class="line"><span class="section">blah.o: blah.c</span></span><br><span class="line">    cc -c blah.c -o blah.o <span class="comment"># Runs second</span></span><br><span class="line"></span><br><span class="line"><span class="section">blah.c:</span></span><br><span class="line">    echo <span class="string">&quot;int main() &#123; return 0; &#125;&quot;</span> &gt; blah.c <span class="comment"># Runs first</span></span><br></pre></td></tr></table></figure>

<p>注：<code>-c</code> 选项告诉编译器只编译源文件，而不进行链接。<code>-o file</code> 将其前面命令的输出内容放在文件file中</p>
<h4 id="Makefile的变量"><a href="#Makefile的变量" class="headerlink" title="Makefile的变量"></a>Makefile的变量</h4><p>Makefile中的变量可以用来简化和组织构建过程。变量可以在Makefile中定义，并在规则和命令中使用。下面是一个简单的示例：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CC = gcc</span><br><span class="line">CFLAGS = -Wall -g</span><br><span class="line">LDFLAGS = -lm</span><br><span class="line">SOURCES = main.c utils.c</span><br><span class="line">OBJECTS = $(SOURCES:.c=.o)</span><br><span class="line">TARGET = my_program</span><br><span class="line"><span class="comment"># 默认目标</span></span><br><span class="line"><span class="section">all: <span class="variable">$(TARGET)</span></span></span><br><span class="line"><span class="comment"># 目标规则</span></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJECTS)</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(LDFLAGS)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"><span class="comment"># 依赖规则</span></span><br><span class="line"><span class="section">%.o: %.c</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="comment"># 清理目标</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -f <span class="variable">$(OBJECTS)</span> <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure>
<p>在这个示例中，我们定义了一些变量，如<code>CC</code>、<code>CFLAGS</code>、<code>LDFLAGS</code>等。然后在规则和命令中使用这些变量，使得Makefile更加灵活和易于维护。<br>引用变量的语法是<code>$(VARIABLE_NAME)</code>，其中<code>VARIABLE_NAME</code>是变量的名称。我们可以在Makefile中使用变量来简化命令和规则的编写。</p>
<h4 id="make是如何工作的"><a href="#make是如何工作的" class="headerlink" title="make是如何工作的"></a>make是如何工作的</h4><p>在默认的方式下，输入<code>make</code>命令。</p>
<ul>
<li>make会在当前目录下查找Makefile文件</li>
<li>如果找到，它会找文件中的第一个目标文件(target)。并把这个文件作为最终的目标文件</li>
<li>如果目标文件不存在，或者目标所依赖的后面的<code>.o</code>文件的文件修改时间要比目标文件这个文件新，那么，它会执行后面所定义的命令来生成目标文件</li>
<li>如果目标文件所依赖的<code>.o</code>文件也不存在，那么make会在当前文件中找目标为<code>.o</code>文件的依赖性，如果找到则再根据那一个规则生成<code>.o</code>文件,然后再用<code>.o</code>文件生成make的最终任务，而就是可执行文件了。</li>
</ul>
<p>这就是整个make的依赖性，make会一层又一层地去找文件的依赖关系，直到最终编译出第一个目标文件。在找寻的过程中，如果出现错误，比如最后被依赖的文件找不到，那么make就会直接退出，并报错，而对于所定义的命令的错误，或是编译不成功，make根本不理。make只管文件的依赖性，即，如果在我找了依赖关系之后，冒号后面的文件还是不在，那么对不起，我就不工作啦。</p>
<p>通过上述分析，我们知道，像clean这种，没有被第一个目标文件直接或间接关联，那么它后面所定义的命令将不会被自动执行，不过，我们可以显示要make执行。即命令—— make clean ，以此来清除所有的目标文件，以便重编译。</p>
<p>于是在我们编程中，如果这个工程已被编译过了，当我们修改了其中一个源文件，比如 file.c ，那么根据我们的依赖性，我们的目标 file.o 会被重编译（也就是在这个依性关系后面所定义的命令），于是 file.o 的文件也是最新的啦，于是 file.o 的文件修改时间要比 edit 要新，所以 edit 也会被重新链接了（详见 edit 目标文件后定义的命令）。</p>
<p>而如果我们改变了 command.h ，那么， kdb.o 、 command.o 和 files.o 都会被重编译，并且， edit 会被重链接。</p>
]]></content>
      <categories>
        <category>Makefile</category>
      </categories>
      <tags>
        <tag>Makefile</tag>
        <tag>自动化构建</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp笔记</title>
    <url>/2025/04/08/cpp-notebook/</url>
    <content><![CDATA[<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ul>
<li>单行注释：<code>//</code></li>
<li>多行注释：<code>/* 注释内容 */</code></li>
<li>文档注释：<code>/// 注释内容</code> 或 <code>/** 注释内容 */</code></li>
<li>文档注释用于生成文档，通常与Doxygen等工具结合使用。</li>
<li>文档注释的格式为<code>/**</code>开头，<code>*/</code>结尾，中间可以包含参数、返回值等信息。</li>
<li>示例：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 计算两个整数的和</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param a 第一个整数</span></span><br><span class="line"><span class="comment"> * @param b 第二个整数</span></span><br><span class="line"><span class="comment"> * @return int 两个整数的和</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>文档注释可以用于函数、类、变量等的描述，方便生成API文档。</li>
</ul>
<span id="more"></span>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul>
<li>变量声明：<code>int a;</code></li>
<li>变量初始化：<code>int a = 10;</code></li>
<li>变量赋值：<code>a = 20;</code></li>
<li>变量类型：<code>int</code>、<code>float</code>、<code>double</code>、<code>char</code>、<code>bool</code>等</li>
<li>常量声明：<code>const int MAX = 100;</code></li>
<li>常量初始化：<code>const int MAX = 100;</code></li>
<li>常量赋值：<code>MAX = 200;</code> &#x2F;&#x2F; 错误，常量不能被修改</li>
<li>常量类型：<code>const int</code>、<code>const float</code>、<code>const double</code>、<code>const char</code>、<code>const bool</code>等</li>
<li>常量的作用域：常量的作用域与变量相同，可以是全局的或局部的。</li>
<li>常量的命名：常量的命名通常使用大写字母和下划线分隔，例如<code>MAX_VALUE</code>。</li>
<li>常量的使用：常量可以用于定义数组大小、循环次数等场景，避免魔法数字的出现，提高代码可读性。</li>
<li>常量的优点：常量可以提高代码的可读性和可维护性，避免了魔法数字的出现。</li>
<li>常量的缺点：常量的值在编译时确定，不能在运行时修改，可能导致灵活性不足。</li>
<li>常量的使用场景：常量通常用于定义一些固定的值，例如数学常数、配置参数等。</li>
<li>常量的命名规范：常量的命名通常使用大写字母和下划线分隔，例如<code>MAX_VALUE</code>，以便于区分变量和常量。</li>
</ul>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul>
<li>基本数据类型：<code>int</code>、<code>float</code>、<code>double</code>、<code>char</code>、<code>bool</code></li>
<li>复合数据类型：<code>struct</code>、<code>union</code>、<code>enum</code></li>
<li>指针类型：<code>int*</code>、<code>float*</code>、<code>char*</code></li>
<li>引用类型：<code>int&amp;</code>、<code>float&amp;</code>、<code>char&amp;</code></li>
<li>数组类型：<code>int[]</code>、<code>float[]</code>、<code>char[]</code></li>
<li>字符串类型：<code>std::string</code></li>
<li>STL容器类型：<code>std::vector</code>、<code>std::list</code>、<code>std::map</code></li>
<li>自定义数据类型：<code>class</code>、<code>struct</code></li>
<li>基本数据类型的大小：<code>sizeof(int)</code>、<code>sizeof(float)</code>、<code>sizeof(double)</code>、<code>sizeof(char)</code>、<code>sizeof(bool)</code></li>
<li>基本数据类型的范围：<code>INT_MIN</code>、<code>INT_MAX</code>、<code>FLOAT_MIN</code>、<code>FLOAT_MAX</code>、<code>DOUBLE_MIN</code>、<code>DOUBLE_MAX</code></li>
<li>基本数据类型的默认值：<code>int</code>默认为0，<code>float</code>默认为0.0，<code>double</code>默认为0.0，<code>char</code>默认为’\0’，<code>bool</code>默认为false</li>
<li>基本数据类型的初始化：<code>int a = 10;</code>、<code>float b = 3.14;</code>、<code>double c = 2.718;</code>、<code>char d = &#39;A&#39;;</code>、<code>bool e = true;</code></li>
<li>基本数据类型的赋值：<code>a = 20;</code>、<code>b = 2.71;</code>、<code>c = 3.14;</code>、<code>d = &#39;B&#39;;</code>、<code>e = false;</code></li>
<li>基本数据类型的使用：<code>std::cout &lt;&lt; a;</code>、<code>std::cin &gt;&gt; b;</code>、<code>std::cout &lt;&lt; c;</code>、<code>std::cin &gt;&gt; d;</code>、<code>std::cout &lt;&lt; e;</code></li>
<li>基本数据类型的转换：<code>int</code>转<code>float</code>：<code>float f = (float)a;</code>、<code>float</code>转<code>int</code>：&#96;int g &#x3D; (int)b;其他类型转换类似。</li>
</ul>
<h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><h1 id="举个例子说明"><a href="#举个例子说明" class="headerlink" title="举个例子说明"></a>举个例子说明</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> globalVar = <span class="number">10</span>; <span class="comment">// 全局变量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> localVar = <span class="number">20</span>; <span class="comment">// 局部变量</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Local variable: &quot;</span> &lt;&lt; localVar &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Global variable: &quot;</span> &lt;&lt; globalVar &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">function</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Global variable: &quot;</span> &lt;&lt; globalVar &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot;Local variable: &quot; &lt;&lt; localVar &lt;&lt; endl; // 错误，localVar在这里不可见</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>在上面的例子中，<code>globalVar</code>是一个全局变量，可以在整个程序中访问。</li>
<li><code>localVar</code>是一个局部变量，只能在<code>function</code>函数内部访问。</li>
<li>在<code>main</code>函数中，尝试访问<code>localVar</code>会导致编译错误，因为它在<code>main</code>函数的作用域内不可见。</li>
<li>变量的作用域决定了变量在程序中的可见性和生命周期。</li>
<li>全局变量在整个程序中可见，生命周期从程序开始到结束。</li>
<li>局部变量在函数内部可见，生命周期从函数调用开始到函数返回结束。</li>
<li>变量的作用域可以通过使用<code>static</code>关键字来限制，例如：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> staticVar = <span class="number">30</span>; <span class="comment">// 静态全局变量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> staticLocalVar = <span class="number">40</span>; <span class="comment">// 静态局部变量</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Static local variable: &quot;</span> &lt;&lt; staticLocalVar &lt;&lt; endl;</span><br><span class="line">    staticLocalVar++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">function</span>();</span><br><span class="line">    <span class="built_in">function</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Static global variable: &quot;</span> &lt;&lt; staticVar &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在上面的例子中，<code>staticVar</code>是一个静态全局变量，可以在整个程序中访问，但它的值在程序运行期间保持不变。</li>
<li><code>staticLocalVar</code>是一个静态局部变量，它的值在函数调用之间保持不变。</li>
<li>静态变量的生命周期从程序开始到结束，但它的作用域限制在定义它的函数内部。</li>
<li>静态变量的值在函数调用之间保持不变，可以用于保存函数的状态。</li>
<li>静态变量的作用域限制在定义它的函数内部，但它的生命周期从程序开始到结束。</li>
<li>静态变量的优点是可以在函数调用之间保持状态，避免了全局变量的使用。</li>
<li>静态变量的缺点是作用域限制在定义它的函数内部，可能导致代码可读性降低。</li>
<li>静态变量的使用场景：静态变量通常用于保存函数的状态，例如计数器、缓存等。</li>
<li>静态变量的命名规范：静态变量的命名通常使用小写字母和下划线分隔，例如<code>static_var</code>，以便于区分全局变量和静态变量。</li>
<li>静态变量的初始化：静态变量的初始化通常在定义时进行，例如<code>static int staticVar = 0;</code>，也可以在函数内部进行初始化，例如<code>static int staticLocalVar = 0;</code>。</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>所有权和借用</title>
    <url>/2025/04/10/ownership-and-borrowing/</url>
    <content><![CDATA[<h1 id="Rust的所有权和借用"><a href="#Rust的所有权和借用" class="headerlink" title="Rust的所有权和借用"></a>Rust的所有权和借用</h1><p>内存回收是编程语言设计的重点之一，如今的计算机语言中，关于内存回收的机制出现三种流派：</p>
<ul>
<li>垃圾回收机制 （Garbage Collection），在程序运行时自动回收不再使用的内存。</li>
<li>手动管理内存的分配和释放，在程序中，通过函数调用的方式申请和释放内存。</li>
<li>通过所有权来管理内存的分配和释放，Rust就是这种语言。</li>
</ul>
<p><strong>一段不安全的代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    a = <span class="number">100</span>;</span><br><span class="line">    <span class="type">char</span> *c = <span class="string">&quot;xyz&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> &amp;a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码中，a是局部变量，当函数结束后将局部变量a的地址返回，a存在栈中，在离开作用域后，a所申请的栈上内存会被系统回收，从而造成了悬空指针的错误。这是一个非常典型的内存安全的问题。虽然编译可以通过，但是运行的时候会出现错误。<br>再来看变量c，c的值是常量字符串，存储于常量区，我们可能只用一次，但必须”xyz”只有当整个程序结束后才会回收这片内存。</p>
<span id="more"></span>
<h2 id="栈和堆"><a href="#栈和堆" class="headerlink" title="栈和堆"></a>栈和堆</h2><p>对于大小为止或可能变换的数据，我们需要存储在堆上。当向堆上放入数据时，需要请求一定大小的内存空间。操作系统在堆的某处找到一块足够大的空位，把它标记为已使用，并返回一个表示该位置地址的指针，该过程被称为在堆上分配内存，有时简称为 “分配”(allocating)。</p>
<p>接着，该指针会被推入栈中，因为指针的大小是已知且固定的，在后续使用过程中，你将通过栈中的指针，来获取数据在堆上的实际内存位置，进而访问该数据。</p>
<p><strong>所有权原则</strong></p>
<ul>
<li>Rust 中每一个值都被一个变量所拥有，该变量被称为值的所有者</li>
<li>一个值同时只能被一个变量所拥有，或者说一个值只能拥有一个所有者</li>
<li>当所有者（变量）离开作用域范围时，这个值将被丢弃(drop)</li>
</ul>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>vim快捷键</title>
    <url>/2025/04/04/vim-shortcut-keys/</url>
    <content><![CDATA[<h2 id="vim键盘图"><a href="#vim键盘图" class="headerlink" title="vim键盘图"></a>vim键盘图</h2><p><img src="/images/image.jpg" alt="vim键盘图"></p>
<span id="more"></span>
<h3 id="vim快捷键"><a href="#vim快捷键" class="headerlink" title="vim快捷键"></a>vim快捷键</h3><h4 id="如何使用vimv"><a href="#如何使用vimv" class="headerlink" title="如何使用vimv"></a>如何使用vimv</h4><p>在终端中输入<code>vim</code>命令，进入vim编辑器。vim有三种模式：普通模式、插入模式和命令模式。</p>
<ul>
<li>普通模式：默认模式，可以使用各种快捷键进行文本编辑。</li>
<li>插入模式：用于输入文本，可以使用<code>i</code>、<code>a</code>等命令进入。</li>
<li>命令模式：用于执行命令，可以使用<code>:</code>进入。<br>在普通模式下，按<code>i</code>进入插入模式，按<code>Esc</code>返回普通模式。<br>在插入模式下，按<code>Esc</code>返回普通模式，按<code>:</code>进入命令模式。<br>在命令模式下，可以输入各种命令，如保存、退出等。</li>
</ul>
<h4 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h4><p>在命令模式下，可以输入各种命令，如保存、退出等。常用命令如下：</p>
<ul>
<li><code>:w</code>：保存文件</li>
<li><code>:q</code>：退出vim</li>
<li><code>:wq</code>：保存并退出vim</li>
<li><code>:q!</code>：强制退出vim，不保存文件</li>
<li><code>:e filename</code>：打开文件</li>
<li><code>:help</code>：查看帮助文档</li>
</ul>
<h4 id="普通模式"><a href="#普通模式" class="headerlink" title="普通模式"></a>普通模式</h4><p>在普通模式下，可以使用各种快捷键进行文本编辑。常用快捷键如下：</p>
<ul>
<li><code>h</code>：向左移动光标</li>
<li><code>j</code>：向下移动光标</li>
<li><code>k</code>：向上移动光标</li>
<li><code>l</code>：向右移动光标</li>
<li><code>0</code>：移动到行首</li>
<li><code>$</code>：移动到行尾</li>
<li><code>gg</code>：移动到文件开头</li>
<li><code>G</code>：移动到文件结尾</li>
<li><code>x</code>：删除光标所在字符</li>
<li><code>dd</code>：删除光标所在行</li>
<li><code>yy</code>：复制光标所在行</li>
<li><code>P</code>(大写)：粘贴剪切板内容到光标上方</li>
<li><code>p</code>(小写)：粘贴剪切板内容到光标下方</li>
<li><code>u</code>：撤销上一次操作</li>
<li><code>v</code>：进入可视模式，可以选择文本</li>
<li><code>y</code>：复制选中的文本</li>
<li><code>d</code>：删除选中的文本</li>
<li><code>c</code>：剪切选中的文本</li>
<li><code>r</code>：替换光标所在字符</li>
<li><code>.</code>：重复上一个操作</li>
<li><code>Ctrl + r</code>：重做上一个操作</li>
<li><code>:w</code>:保存文件</li>
<li><code>:q</code>:退出vim</li>
<li><code>:wq</code>:保存并退出vim</li>
<li><code>:q!</code>:强制退出vim，不保存文件</li>
</ul>
<h4 id="插入模式"><a href="#插入模式" class="headerlink" title="插入模式"></a>插入模式</h4><p>在插入模式下，可以输入文本。常用快捷键如下：</p>
<ul>
<li><code>i</code>：在光标前插入文本</li>
<li><code>I</code>：在行首插入文本</li>
<li><code>a</code>：在光标后插入文本</li>
<li><code>A</code>：在行尾插入文本</li>
<li><code>o</code>：在光标下方插入新行</li>
<li><code>O</code>：在光标上方插入新行</li>
<li><code>Esc</code>：返回普通模式</li>
</ul>
<h4 id="可视模式"><a href="#可视模式" class="headerlink" title="可视模式"></a>可视模式</h4><p>在可视模式下，可以选择文本。常用快捷键如下：</p>
<ul>
<li><code>v</code>：进入可视模式</li>
<li><code>V</code>：进入行可视模式</li>
<li><code>Ctrl + v</code>：进入块可视模式</li>
<li><code>y</code>：复制选中的文本</li>
<li><code>d</code>：删除选中的文本</li>
<li><code>c</code>：剪切选中的文本</li>
<li><code>p</code>：粘贴</li>
<li><code>u</code>：撤销</li>
</ul>
<h3 id="vim按键说明"><a href="#vim按键说明" class="headerlink" title="vim按键说明"></a>vim按键说明</h3><h4 id="第一部分：一般模式的光标移动，复制粘贴、搜索替换等"><a href="#第一部分：一般模式的光标移动，复制粘贴、搜索替换等" class="headerlink" title="第一部分：一般模式的光标移动，复制粘贴、搜索替换等"></a>第一部分：一般模式的光标移动，复制粘贴、搜索替换等</h4><h4 id="移动光标的方法"><a href="#移动光标的方法" class="headerlink" title="移动光标的方法"></a>移动光标的方法</h4><table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ctrl + f</code></td>
<td>屏幕向下移动一页</td>
</tr>
<tr>
<td><code>ctrl + b</code></td>
<td>屏幕向上移动一页</td>
</tr>
<tr>
<td><code>ctrl + d</code></td>
<td>屏幕向下移动半页</td>
</tr>
<tr>
<td><code>ctrl + u</code></td>
<td>屏幕向上移动半页</td>
</tr>
<tr>
<td><code>n&lt;space&gt;</code></td>
<td>按下数字后再按空格键，光标会向右移动这一行的n个字符。例如20<space>则光标会向后面移动20个字符距离</space></td>
</tr>
<tr>
<td><code>0</code></td>
<td>光标移动到行首</td>
</tr>
<tr>
<td><code>$</code></td>
<td>光标移动到行尾</td>
</tr>
<tr>
<td><code>gg</code></td>
<td>光标移动到文件开头</td>
</tr>
<tr>
<td><code>G</code></td>
<td>光标移动到文件结尾</td>
</tr>
<tr>
<td><code>n&lt;Enter&gt;</code></td>
<td>光标移动到当前行的第n个字符</td>
</tr>
<tr>
<td><code>nG</code></td>
<td>光标移动到第n行</td>
</tr>
</tbody></table>
<h4 id="搜索替换"><a href="#搜索替换" class="headerlink" title="搜索替换"></a>搜索替换</h4><table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>/word</code></td>
<td>向光标之下寻找一个名称为word的字符串。例如要在档案内搜寻vbird这个字符串，就输入&#x2F;vbird即可</td>
</tr>
<tr>
<td><code>?word</code></td>
<td>向光标之上寻找一个名称为word的字符串</td>
</tr>
<tr>
<td><code>n</code></td>
<td>搜寻下一个</td>
</tr>
<tr>
<td><code>N</code></td>
<td>搜寻上一个</td>
</tr>
<tr>
<td><code>:%s/old/new/g</code></td>
<td>将档案内的old字串替换成new字串</td>
</tr>
</tbody></table>
<h4 id="复制、剪切、粘贴"><a href="#复制、剪切、粘贴" class="headerlink" title="复制、剪切、粘贴"></a>复制、剪切、粘贴</h4><table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>x</code></td>
<td>删除光标所在的字符</td>
</tr>
<tr>
<td><code>X</code></td>
<td>删除光标前的字符</td>
</tr>
<tr>
<td><code>dd</code></td>
<td>删除光标所在的行</td>
</tr>
<tr>
<td><code>ndd</code></td>
<td>n为数字。剪切光标所在的向下n行,例如20dd则是剪切20行，用p&#x2F;P可以粘贴</td>
</tr>
<tr>
<td><code>d1G</code></td>
<td>删除光标所在行到第一行的所有数据</td>
</tr>
<tr>
<td><code>dG</code></td>
<td>删除光标所在行到最后一行的所有数据</td>
</tr>
<tr>
<td><code>d0</code></td>
<td>那个是数字的0,删除游标所在处，到该行的最前面的一个字符</td>
</tr>
<tr>
<td><code>yy</code></td>
<td>复制光标所在行</td>
</tr>
<tr>
<td><code>nyy</code></td>
<td>n为数字。复制光标所在行向下n行,例如20yy则是复制20行，用p&#x2F;P可以粘贴</td>
</tr>
<tr>
<td><code>y1G</code></td>
<td>复制光标所在行到第一行的所有数据</td>
</tr>
<tr>
<td><code>yG</code></td>
<td>复制光标所在行到最后一行的所有数据</td>
</tr>
<tr>
<td><code>y0</code></td>
<td>复制光标所在行到该行的最前面的一个字符</td>
</tr>
<tr>
<td><code>y$</code></td>
<td>复制光标所在的那个字符到该行行尾的所有数据</td>
</tr>
<tr>
<td><code>p</code></td>
<td>粘贴到光标后面</td>
</tr>
<tr>
<td><code>P</code></td>
<td>粘贴到光标前面</td>
</tr>
<tr>
<td><code>J</code></td>
<td>将光标所在行与下一行合并</td>
</tr>
<tr>
<td><code>u</code></td>
<td>撤销上一个操作</td>
</tr>
<tr>
<td><code>c</code></td>
<td>重复删除多个数据，例如向下删除10行, [10cj]</td>
</tr>
</tbody></table>
<h4 id="个人快捷键的配置"><a href="#个人快捷键的配置" class="headerlink" title="个人快捷键的配置"></a>个人快捷键的配置</h4><p>我个人的主键是空格<code> </code></p>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;leader&gt;t</code></td>
<td>打开终端</td>
</tr>
<tr>
<td><code>&lt;leader&gt;n</code></td>
<td>打开文件树</td>
</tr>
<tr>
<td><code>&lt;leader&gt;f</code></td>
<td>打开文件树并定位到当前文件</td>
</tr>
<tr>
<td><code>&lt;C-h&gt;</code></td>
<td>切换到左标签页</td>
</tr>
<tr>
<td><code>&lt;C-l&gt;</code></td>
<td>切换到右标签页</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>vim</category>
      </categories>
      <tags>
        <tag>快捷键说明</tag>
      </tags>
  </entry>
  <entry>
    <title>vscode快捷键</title>
    <url>/2025/04/08/vscode-shortcut-keys/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="工作区快捷键"><a href="#工作区快捷键" class="headerlink" title="工作区快捷键"></a>工作区快捷键</h3><table>
<thead>
<tr>
<th>Linux&#x2F;Windows</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl + Shift + P</td>
<td>打开命令面板</td>
</tr>
<tr>
<td>Ctrl + B</td>
<td>显示&#x2F;隐藏侧边栏</td>
</tr>
<tr>
<td>Ctrl + \</td>
<td>拆分编辑器</td>
</tr>
<tr>
<td>Ctrl + Tab</td>
<td>切换编辑器</td>
</tr>
<tr>
<td>Ctrl + + 、Ctrl + -</td>
<td>放大&#x2F;缩小编辑器</td>
</tr>
<tr>
<td>Ctrl + N</td>
<td>新建文件</td>
</tr>
<tr>
<td>Ctrl + W</td>
<td>关闭当前文件</td>
</tr>
<tr>
<td>Ctrl + &#96;</td>
<td>打开终端</td>
</tr>
</tbody></table>
<h3 id="跳转操作"><a href="#跳转操作" class="headerlink" title="跳转操作"></a>跳转操作</h3><table>
<thead>
<tr>
<th>Linux&#x2F;Windows</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl + PageUp&#x2F;PageDown</td>
<td>在已经打开的多个文件之间进行切换</td>
</tr>
<tr>
<td>Ctrl + Shift + E</td>
<td>显示资源管理器</td>
</tr>
<tr>
<td>Ctrl + Shift + F</td>
<td>显示搜索</td>
</tr>
<tr>
<td>Ctrl + shift + O</td>
<td>在当前文件的各种方法之间进行跳转</td>
</tr>
<tr>
<td>Ctrl + G</td>
<td>跳转到指定行</td>
</tr>
<tr>
<td>Ctrl + Shift + \</td>
<td>跳转到匹配的括号</td>
</tr>
</tbody></table>
<h3 id="编辑操作"><a href="#编辑操作" class="headerlink" title="编辑操作"></a>编辑操作</h3><table>
<thead>
<tr>
<th>Linux&#x2F;Windows</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl + Enter</td>
<td>在当前行的下方新增一行，然后跳转至该行</td>
</tr>
<tr>
<td>Ctrl + Shift + Enter</td>
<td>在当前行的上方新增一行，然后跳转至该行</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>vscode</category>
      </categories>
      <tags>
        <tag>快捷键说明</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么悬垂指针在rust里是不安全的</title>
    <url>/2025/04/10/why-dangling-references-are-unsafe-in-rust-md/</url>
    <content><![CDATA[<p>在 Rust 中，<strong>悬垂引用（Dangling Reference）</strong> 是一种严重的内存安全问题，因为它会导致程序访问已释放或无效的内存，从而引发未定义行为（Undefined Behavior, UB）。Rust 的所有权系统和借用检查器（Borrow Checker）的核心目标之一就是<strong>在编译时彻底杜绝悬垂引用</strong>。以下是详细解释：</p>
<hr>
<h3 id="1-什么是悬垂引用？"><a href="#1-什么是悬垂引用？" class="headerlink" title="1. 什么是悬垂引用？"></a>1. <strong>什么是悬垂引用？</strong></h3><p>悬垂引用是指一个指针或引用指向的内存地址<strong>已被释放或不再有效</strong>，但程序仍尝试通过该引用访问数据。例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">dangling_reference</span>() <span class="punctuation">-&gt;</span> &amp;<span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>); <span class="comment">// `s` 在函数结束时被销毁</span></span><br><span class="line">    &amp;s <span class="comment">// 返回一个指向已释放内存的引用（编译错误！）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Rust 编译器会直接拒绝此类代码，因为 <code>s</code> 的生命周期仅限于函数内部，而返回的引用会超出其生命周期。</p>
<span id="more"></span>
<hr>
<h3 id="2-为什么悬垂引用危险？"><a href="#2-为什么悬垂引用危险？" class="headerlink" title="2. 为什么悬垂引用危险？"></a>2. <strong>为什么悬垂引用危险？</strong></h3><ul>
<li><strong>未定义行为（UB）</strong>：访问已释放的内存可能导致程序崩溃、数据损坏或安全漏洞（如攻击者利用悬垂指针注入恶意代码）。</li>
<li><strong>难以调试</strong>：悬垂引用的问题可能在运行时随机出现，且难以复现（取决于内存分配器的行为）。</li>
</ul>
<hr>
<h3 id="3-Rust-如何防止悬垂引用？"><a href="#3-Rust-如何防止悬垂引用？" class="headerlink" title="3. Rust 如何防止悬垂引用？"></a>3. <strong>Rust 如何防止悬垂引用？</strong></h3><p>Rust 通过以下机制在编译时静态检查所有引用的有效性：</p>
<h4 id="（1）生命周期标注（Lifetimes）"><a href="#（1）生命周期标注（Lifetimes）" class="headerlink" title="（1）生命周期标注（Lifetimes）"></a>（1）<strong>生命周期标注（Lifetimes）</strong></h4><ul>
<li>显式或隐式标注引用的生命周期，确保引用不会比其引用的数据存活更久。</li>
<li>示例：<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>&lt;<span class="symbol">&#x27;a</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, y: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.<span class="title function_ invoke__">len</span>() &gt; y.<span class="title function_ invoke__">len</span>() &#123; x &#125; <span class="keyword">else</span> &#123; y &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
编译器会确保返回的引用 <code>&amp;&#39;a str</code> 不会超过输入参数的生命周期。</li>
</ul>
<h4 id="（2）所有权规则"><a href="#（2）所有权规则" class="headerlink" title="（2）所有权规则"></a>（2）<strong>所有权规则</strong></h4><ul>
<li>数据的所有者（Owner）负责释放内存，引用（Borrow）必须遵守所有权的生命周期。</li>
<li>任何试图返回悬垂引用的代码都会被编译器拒绝：<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">invalid</span>() <span class="punctuation">-&gt;</span> &amp;<span class="type">i32</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">42</span>;</span><br><span class="line">    &amp;x <span class="comment">// 错误！`x` 的生命周期不足</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="（3）借用检查器（Borrow-Checker）"><a href="#（3）借用检查器（Borrow-Checker）" class="headerlink" title="（3）借用检查器（Borrow Checker）"></a>（3）<strong>借用检查器（Borrow Checker）</strong></h4><ul>
<li>在编译时分析所有引用的作用域，确保：<ul>
<li>引用不会比其引用的数据存活更久。</li>
<li>不存在数据竞争（通过 <code>可变引用独占性</code> 规则）。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="4-对比其他语言"><a href="#4-对比其他语言" class="headerlink" title="4. 对比其他语言"></a>4. <strong>对比其他语言</strong></h3><ul>
<li><strong>C&#x2F;C++</strong>：允许悬垂指针，需程序员手动保证安全（极易出错）。</li>
<li><strong>Java&#x2F;Python</strong>：通过垃圾回收（GC）避免悬垂引用，但牺牲性能和实时性。</li>
<li><strong>Rust</strong>：<strong>零成本抽象</strong>，无需运行时 GC，完全在编译期解决问题。</li>
</ul>
<hr>
<h3 id="5-如何避免悬垂引用？"><a href="#5-如何避免悬垂引用？" class="headerlink" title="5. 如何避免悬垂引用？"></a>5. <strong>如何避免悬垂引用？</strong></h3><ul>
<li><strong>遵循所有权规则</strong>：确保引用的作用域不超过被引用数据。</li>
<li><strong>使用生命周期参数</strong>：在函数或结构体中显式标注生命周期。</li>
<li><strong>必要时转移所有权</strong>：返回数据本身而非引用（如返回 <code>String</code> 而非 <code>&amp;String</code>）。</li>
</ul>
<hr>
<h3 id="示例：安全的替代方案"><a href="#示例：安全的替代方案" class="headerlink" title="示例：安全的替代方案"></a>示例：安全的替代方案</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">no_dangle</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123; <span class="comment">// 返回所有权而非引用</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    s <span class="comment">// 转移所有权到调用者</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>内存安全</tag>
        <tag>悬垂引用</tag>
        <tag>生命周期</tag>
      </tags>
  </entry>
</search>
