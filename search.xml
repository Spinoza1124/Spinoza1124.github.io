<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Makefile教程</title>
    <url>/2025/04/08/Makefile%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>Makefile是一个自动化构建工具，通常用于编译和链接程序。它通过定义规则和依赖关系来自动化构建过程，从而简化了软件开发中的重复性任务。<br>Makefile的基本结构包括目标、依赖和命令。目标是要生成的文件，依赖是生成目标所需的文件，命令是在生成目标时执行的操作。</p>
<span id="more"></span>

<h4 id="如何运行示例"><a href="#如何运行示例" class="headerlink" title="如何运行示例"></a>如何运行示例</h4><p>首先安装make终端。对于Linux和MacOS，通常已经预装了make。对于Windows用户，可以使用WSL（Windows Subsystem for Linux）或安装GNU Make。<br>在终端中，进入到包含Makefile的目录，然后运行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>
<p>这将根据Makefile中的规则自动执行构建过程。<br>如果要运行特定的目标，可以在命令后指定目标名称，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make clean</span><br></pre></td></tr></table></figure>
<p>这将执行Makefile中定义的<code>clean</code>目标，通常用于清理生成的文件。</p>
<h4 id="Makefile示例"><a href="#Makefile示例" class="headerlink" title="Makefile示例"></a>Makefile示例</h4><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Makefile示例</span></span><br><span class="line">CC = gcc</span><br><span class="line">CFLAGS = -Wall -g</span><br><span class="line">LDFLAGS = -lm</span><br><span class="line">SOURCES = main.c utils.c</span><br><span class="line">OBJECTS = $(SOURCES:.c=.o)</span><br><span class="line">TARGET = my_program</span><br><span class="line"><span class="comment"># 默认目标</span></span><br><span class="line"><span class="section">all: <span class="variable">$(TARGET)</span></span></span><br><span class="line"><span class="comment"># 目标规则</span></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJECTS)</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(LDFLAGS)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"><span class="comment"># 依赖规则</span></span><br><span class="line"><span class="section">%.o: %.c</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="comment"># 清理目标</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -f <span class="variable">$(OBJECTS)</span> <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure>
<h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><ul>
<li><code>CC</code>：指定编译器，这里使用gcc。</li>
<li><code>CFLAGS</code>：编译选项，这里启用所有警告并生成调试信息。</li>
<li><code>LDFLAGS</code>：链接选项，这里链接数学库。</li>
<li><code>SOURCES</code>：源文件列表。</li>
<li><code>OBJECTS</code>：目标文件列表，通过将源文件扩展名从.c更改为.o来生成。</li>
<li><code>TARGET</code>：最终生成的可执行文件名称。</li>
<li><code>all</code>：默认目标，当运行<code>make</code>时执行。</li>
<li><code>$(TARGET)</code>：依赖于所有目标文件，使用<code>$@</code>表示目标名称，<code>$^</code>表示所有依赖文件。</li>
<li><code>%.o: %.c</code>：模式规则，表示如何从源文件生成目标文件。</li>
<li><code>clean</code>：清理目标，删除所有生成的文件。</li>
</ul>
<h1 id="根据上面的Makefile，举一个实际的例子"><a href="#根据上面的Makefile，举一个实际的例子" class="headerlink" title="根据上面的Makefile，举一个实际的例子"></a>根据上面的Makefile，举一个实际的例子</h1><p>假设我们有两个C源文件<code>main.c</code>和<code>utils.c</code>，以及一个头文件<code>utils.h</code>。我们希望编译这些文件并生成一个名为<code>my_program</code>的可执行文件。<br><code>main.c</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utils.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, World!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>utils.c</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utils.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_message</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This is a message from utils.c\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>utils.h</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> UTILS_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UTILS_H</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_message</span><span class="params">()</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>在终端中，进入到包含这些文件的目录，然后运行<code>make</code>命令。Makefile将自动编译<code>main.c</code>和<code>utils.c</code>，并生成一个名为<code>my_program</code>的可执行文件。<br>运行<code>./my_program</code>将输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hello, World!</span><br><span class="line">This is a message from utils.c</span><br></pre></td></tr></table></figure>

<h4 id="新手示例"><a href="#新手示例" class="headerlink" title="新手示例"></a>新手示例</h4><p>下面的Makefile有3个分离的规则（rules）。当在终端运行<code>make blah</code>时，它会通过一系列的步骤构建一个名为<code>blah</code>的的程序:</p>
<ul>
<li><code>blan</code>给<code>make</code>提供了构建目标(target)的名称, 所以它会在makefile中优先被<code>make</code>程序搜索</li>
<li>构建系统发现<code>blan</code>依赖<code>blah.o</code>,所以<code>make</code>开始搜索<code>blah.o</code>这个目标</li>
<li><code>blah.o</code>没有依赖,直接运行<code>echo</code>命令</li>
<li>接着运行<code>cc -c</code>命令，以为<code>blah.o</code>的依赖的所有<code>commands</code>都执行完了</li>
<li>同理,接着运行顶部的<code>cc</code>命令</li>
<li>就这样,一个编译好的C程序<code>blah</code>就诞生了</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">blah: blah.o</span></span><br><span class="line">    cc -o blah blah.o <span class="comment"># Runs third</span></span><br><span class="line"></span><br><span class="line"><span class="section">blah.o: blah.c</span></span><br><span class="line">    cc -c blah.c -o blah.o <span class="comment"># Runs second</span></span><br><span class="line"></span><br><span class="line"><span class="section">blah.c:</span></span><br><span class="line">    echo <span class="string">&quot;int main() &#123; return 0; &#125;&quot;</span> &gt; blah.c <span class="comment"># Runs first</span></span><br></pre></td></tr></table></figure>

<p>注：<code>-c</code> 选项告诉编译器只编译源文件，而不进行链接。<code>-o file</code> 将其前面命令的输出内容放在文件file中</p>
<h4 id="Makefile的变量"><a href="#Makefile的变量" class="headerlink" title="Makefile的变量"></a>Makefile的变量</h4><p>Makefile中的变量可以用来简化和组织构建过程。变量可以在Makefile中定义，并在规则和命令中使用。下面是一个简单的示例：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CC = gcc</span><br><span class="line">CFLAGS = -Wall -g</span><br><span class="line">LDFLAGS = -lm</span><br><span class="line">SOURCES = main.c utils.c</span><br><span class="line">OBJECTS = $(SOURCES:.c=.o)</span><br><span class="line">TARGET = my_program</span><br><span class="line"><span class="comment"># 默认目标</span></span><br><span class="line"><span class="section">all: <span class="variable">$(TARGET)</span></span></span><br><span class="line"><span class="comment"># 目标规则</span></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJECTS)</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(LDFLAGS)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"><span class="comment"># 依赖规则</span></span><br><span class="line"><span class="section">%.o: %.c</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="comment"># 清理目标</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -f <span class="variable">$(OBJECTS)</span> <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure>
<p>在这个示例中，我们定义了一些变量，如<code>CC</code>、<code>CFLAGS</code>、<code>LDFLAGS</code>等。然后在规则和命令中使用这些变量，使得Makefile更加灵活和易于维护。<br>引用变量的语法是<code>$(VARIABLE_NAME)</code>，其中<code>VARIABLE_NAME</code>是变量的名称。我们可以在Makefile中使用变量来简化命令和规则的编写。</p>
<h4 id="make是如何工作的"><a href="#make是如何工作的" class="headerlink" title="make是如何工作的"></a>make是如何工作的</h4><p>在默认的方式下，输入<code>make</code>命令。</p>
<ul>
<li>make会在当前目录下查找Makefile文件</li>
<li>如果找到，它会找文件中的第一个目标文件(target)。并把这个文件作为最终的目标文件</li>
<li>如果目标文件不存在，或者目标所依赖的后面的<code>.o</code>文件的文件修改时间要比目标文件这个文件新，那么，它会执行后面所定义的命令来生成目标文件</li>
<li>如果目标文件所依赖的<code>.o</code>文件也不存在，那么make会在当前文件中找目标为<code>.o</code>文件的依赖性，如果找到则再根据那一个规则生成<code>.o</code>文件,然后再用<code>.o</code>文件生成make的最终任务，而就是可执行文件了。</li>
</ul>
<p>这就是整个make的依赖性，make会一层又一层地去找文件的依赖关系，直到最终编译出第一个目标文件。在找寻的过程中，如果出现错误，比如最后被依赖的文件找不到，那么make就会直接退出，并报错，而对于所定义的命令的错误，或是编译不成功，make根本不理。make只管文件的依赖性，即，如果在我找了依赖关系之后，冒号后面的文件还是不在，那么对不起，我就不工作啦。</p>
<p>通过上述分析，我们知道，像clean这种，没有被第一个目标文件直接或间接关联，那么它后面所定义的命令将不会被自动执行，不过，我们可以显示要make执行。即命令—— make clean ，以此来清除所有的目标文件，以便重编译。</p>
<p>于是在我们编程中，如果这个工程已被编译过了，当我们修改了其中一个源文件，比如 file.c ，那么根据我们的依赖性，我们的目标 file.o 会被重编译（也就是在这个依性关系后面所定义的命令），于是 file.o 的文件也是最新的啦，于是 file.o 的文件修改时间要比 edit 要新，所以 edit 也会被重新链接了（详见 edit 目标文件后定义的命令）。</p>
<p>而如果我们改变了 command.h ，那么， kdb.o 、 command.o 和 files.o 都会被重编译，并且， edit 会被重链接。</p>
]]></content>
      <categories>
        <category>Makefile</category>
      </categories>
      <tags>
        <tag>Makefile</tag>
        <tag>自动化构建</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown语法</title>
    <url>/2025/04/15/Markdown%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>Markdown 是一种轻量级的标记语言，广泛用于编写文档、博客和技术文章。掌握 Markdown 语法可以帮助你快速创建格式化的文本。可以显著提高文档的可读性和可维护性。</p>
<span id="more"></span>

<p>编写规范的 Markdown 文档可以让内容清晰易读，且兼容性良好。以下是编写高质量 Markdown 的实用指南：</p>
<hr>
<h3 id="1-基础语法规范"><a href="#1-基础语法规范" class="headerlink" title="1. 基础语法规范"></a><strong>1. 基础语法规范</strong></h3><h4 id="（1）标题层级"><a href="#（1）标题层级" class="headerlink" title="（1）标题层级"></a><strong>（1）标题层级</strong></h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 一级标题（建议文档仅用1个）</span></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"><span class="section">#### 四级标题</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>前后空行</strong>：标题上下留空行，避免粘连</li>
<li><strong>避免跳级</strong>：如从 <code>##</code> 直接到 <code>####</code></li>
</ul>
<h4 id="（2）段落与换行"><a href="#（2）段落与换行" class="headerlink" title="（2）段落与换行"></a><strong>（2）段落与换行</strong></h4><ul>
<li><strong>段落间隔</strong>：段落间用空行分隔</li>
<li><strong>强制换行</strong>：行尾添加两个空格（多数渲染器支持直接换行）</li>
</ul>
<h4 id="（3）列表"><a href="#（3）列表" class="headerlink" title="（3）列表"></a><strong>（3）列表</strong></h4><p><strong>有序列表</strong>：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 第一项</span><br><span class="line"><span class="bullet">2.</span> 第二项</span><br><span class="line"><span class="bullet">   -</span> 子项（缩进2或4空格）</span><br></pre></td></tr></table></figure>

<p><strong>无序列表</strong>：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> 项目符号</span><br><span class="line"><span class="bullet">  *</span> 嵌套符号（保持缩进一致）</span><br><span class="line"><span class="bullet">  +</span> 可混合符号（但建议统一风格）</span><br></pre></td></tr></table></figure>

<h4 id="（4）代码块"><a href="#（4）代码块" class="headerlink" title="（4）代码块"></a><strong>（4）代码块</strong></h4><ul>
<li><strong>行内代码</strong>：用反引号包裹 <code>`code`</code></li>
<li><strong>多行代码</strong>：<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="code">```语言类型（如js/python）</span></span><br><span class="line"><span class="code">function hello() &#123;</span></span><br><span class="line"><span class="code">  console.log(&quot;Hello Markdown&quot;);</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line"><span class="code">```</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="（5）链接与图片"><a href="#（5）链接与图片" class="headerlink" title="（5）链接与图片"></a><strong>（5）链接与图片</strong></h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">链接文字</span>](<span class="link">URL &quot;可选标题&quot;</span>)  </span><br><span class="line">![<span class="string">图片描述</span>](<span class="link">图片路径/URL</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>建议相对路径</strong>：若文档用于版本控制（如GitHub），优先使用相对路径引用图片</li>
</ul>
<hr>
<h3 id="2-增强可读性技巧"><a href="#2-增强可读性技巧" class="headerlink" title="2. 增强可读性技巧"></a><strong>2. 增强可读性技巧</strong></h3><h4 id="（1）表格对齐"><a href="#（1）表格对齐" class="headerlink" title="（1）表格对齐"></a><strong>（1）表格对齐</strong></h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">| 左对齐 | 居中对齐 | 右对齐 |</span><br><span class="line">|:-------|:--------:|-------:|</span><br><span class="line">| 数据1  |   数据2  |   数据3|</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>使用工具生成</strong>：推荐 <a href="https://www.tablesgenerator.com/markdown_tables">Tables Generator</a></li>
</ul>
<h4 id="（2）任务列表"><a href="#（2）任务列表" class="headerlink" title="（2）任务列表"></a><strong>（2）任务列表</strong></h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> [x] 已完成任务</span><br><span class="line"><span class="bullet">-</span> [ ] 未完成任务</span><br></pre></td></tr></table></figure>

<h4 id="（3）注释与折叠"><a href="#（3）注释与折叠" class="headerlink" title="（3）注释与折叠"></a><strong>（3）注释与折叠</strong></h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&lt;!-- 这是隐藏的注释 --&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">details</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">summary</span>&gt;</span></span>点击展开详情<span class="language-xml"><span class="tag">&lt;/<span class="name">summary</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">被折叠的内容（支持Markdown语法）</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">details</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-高级扩展语法（需渲染器支持）"><a href="#3-高级扩展语法（需渲染器支持）" class="headerlink" title="3. 高级扩展语法（需渲染器支持）"></a><strong>3. 高级扩展语法（需渲染器支持）</strong></h3><h4 id="（1）流程图与图表"><a href="#（1）流程图与图表" class="headerlink" title="（1）流程图与图表"></a><strong>（1）流程图与图表</strong></h4><p>使用 Mermaid（GitHub&#x2F;GitLab 已原生支持）：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="code">```mermaid</span></span><br><span class="line"><span class="code">graph TD</span></span><br><span class="line"><span class="code">  A[开始] --&gt; B&#123;条件判断&#125;</span></span><br><span class="line"><span class="code">  B --&gt;|是| C[执行操作]</span></span><br><span class="line"><span class="code">  B --&gt;|否| D[结束]</span></span><br><span class="line"><span class="code">```</span></span><br></pre></td></tr></table></figure>

<h4 id="（2）数学公式"><a href="#（2）数学公式" class="headerlink" title="（2）数学公式"></a><strong>（2）数学公式</strong></h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">行内公式：$E = mc^2$</span><br><span class="line"></span><br><span class="line">块级公式：</span><br><span class="line">$$</span><br><span class="line">\sum<span class="emphasis">_&#123;i=1&#125;^n i = \frac&#123;n(n+1)&#125;&#123;2&#125;</span></span><br><span class="line"><span class="emphasis">$$</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-最佳实践"><a href="#4-最佳实践" class="headerlink" title="4. 最佳实践"></a><strong>4. 最佳实践</strong></h3><h4 id="（1）保持一致性"><a href="#（1）保持一致性" class="headerlink" title="（1）保持一致性"></a><strong>（1）保持一致性</strong></h4><ul>
<li><strong>符号统一</strong>：如列表用 <code>-</code> 或 <code>*</code> 保持全文一致</li>
<li><strong>缩进对齐</strong>：嵌套内容统一缩进（推荐2或4空格）</li>
</ul>
<h4 id="（2）语义化写作"><a href="#（2）语义化写作" class="headerlink" title="（2）语义化写作"></a><strong>（2）语义化写作</strong></h4><ul>
<li><strong>避免过度装饰</strong>：少用无意义的加粗&#x2F;斜体</li>
<li><strong>使用引用块</strong>：<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; 引用他人观点或重要说明</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="（3）兼容性处理"><a href="#（3）兼容性处理" class="headerlink" title="（3）兼容性处理"></a><strong>（3）兼容性处理</strong></h4><ul>
<li><strong>转义特殊字符</strong>：如 <code>#</code>、<code>*</code> 前加反斜杠 <code>\#</code></li>
<li><strong>测试渲染效果</strong>：在目标平台（如GitHub、VS Code）预览</li>
</ul>
<hr>
<h3 id="5-工具推荐"><a href="#5-工具推荐" class="headerlink" title="5. 工具推荐"></a><strong>5. 工具推荐</strong></h3><ul>
<li><strong>编辑器</strong>：<ul>
<li><a href="https://typora.io/">Typora</a>（即时渲染）</li>
<li><a href="https://code.visualstudio.com/">VS Code</a> + Markdown插件</li>
</ul>
</li>
<li><strong>校验工具</strong>：<ul>
<li><a href="https://github.com/DavidAnson/markdownlint">markdownlint</a>（自动检查规范）</li>
</ul>
</li>
<li><strong>图床工具</strong>：<ul>
<li><a href="https://github.com/Molunerfinn/PicGo">PicGo</a>（快速上传图片）</li>
</ul>
</li>
</ul>
<hr>
<h3 id="6-示例模板"><a href="#6-示例模板" class="headerlink" title="6. 示例模板"></a><strong>6. 示例模板</strong></h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 项目名称</span></span><br><span class="line"></span><br><span class="line">![<span class="string">项目Logo</span>](<span class="link">logo.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">## 功能特性</span></span><br><span class="line"><span class="bullet">-</span> ✅ 支持核心功能A</span><br><span class="line"><span class="bullet">-</span> 🚧 开发中功能B</span><br><span class="line"></span><br><span class="line"><span class="section">## 快速开始</span></span><br><span class="line"><span class="section">### 安装步骤</span></span><br><span class="line"><span class="code">```bash</span></span><br><span class="line"><span class="code">npm install my-project</span></span><br></pre></td></tr></table></figure>

<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; demo &#125; <span class="keyword">from</span> <span class="string">&#x27;my-project&#x27;</span>;</span><br><span class="line"><span class="title function_">demo</span>();</span><br></pre></td></tr></table></figure>

<h2 id="贡献指南"><a href="#贡献指南" class="headerlink" title="贡献指南"></a>贡献指南</h2><p>请阅读 <a href="docs/CONTRIBUTING.md">CONTRIBUTING.md</a></p>
<h2 id="许可证"><a href="#许可证" class="headerlink" title="许可证"></a>许可证</h2><p><a href="LICENSE">MIT License</a></p>
<pre><code>
---

### **7. 常见错误避免**
- ❌ 标题层级混乱（如从 `#` 直接跳到 `###`）
- ❌ 长段落未分段（超过5行建议拆分）
- ❌ 图片路径失效（建议版本控制中存放到 `/docs/images/`）
- ❌ 使用HTML标签（除非必要，优先用原生Markdown语法）

---
</code></pre>
]]></content>
      <categories>
        <category>Markdown</category>
        <category>编程规范</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp笔记</title>
    <url>/2025/04/08/cpp%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ul>
<li>单行注释：<code>//</code></li>
<li>多行注释：<code>/* 注释内容 */</code></li>
<li>文档注释：<code>/// 注释内容</code> 或 <code>/** 注释内容 */</code></li>
<li>文档注释用于生成文档，通常与Doxygen等工具结合使用。</li>
<li>文档注释的格式为<code>/**</code>开头，<code>*/</code>结尾，中间可以包含参数、返回值等信息。</li>
<li>示例：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 计算两个整数的和</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param a 第一个整数</span></span><br><span class="line"><span class="comment"> * @param b 第二个整数</span></span><br><span class="line"><span class="comment"> * @return int 两个整数的和</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>文档注释可以用于函数、类、变量等的描述，方便生成API文档。</li>
</ul>
<span id="more"></span>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul>
<li>变量声明：<code>int a;</code></li>
<li>变量初始化：<code>int a = 10;</code></li>
<li>变量赋值：<code>a = 20;</code></li>
<li>变量类型：<code>int</code>、<code>float</code>、<code>double</code>、<code>char</code>、<code>bool</code>等</li>
<li>常量声明：<code>const int MAX = 100;</code></li>
<li>常量初始化：<code>const int MAX = 100;</code></li>
<li>常量赋值：<code>MAX = 200;</code> &#x2F;&#x2F; 错误，常量不能被修改</li>
<li>常量类型：<code>const int</code>、<code>const float</code>、<code>const double</code>、<code>const char</code>、<code>const bool</code>等</li>
<li>常量的作用域：常量的作用域与变量相同，可以是全局的或局部的。</li>
<li>常量的命名：常量的命名通常使用大写字母和下划线分隔，例如<code>MAX_VALUE</code>。</li>
<li>常量的使用：常量可以用于定义数组大小、循环次数等场景，避免魔法数字的出现，提高代码可读性。</li>
<li>常量的优点：常量可以提高代码的可读性和可维护性，避免了魔法数字的出现。</li>
<li>常量的缺点：常量的值在编译时确定，不能在运行时修改，可能导致灵活性不足。</li>
<li>常量的使用场景：常量通常用于定义一些固定的值，例如数学常数、配置参数等。</li>
<li>常量的命名规范：常量的命名通常使用大写字母和下划线分隔，例如<code>MAX_VALUE</code>，以便于区分变量和常量。</li>
</ul>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul>
<li>基本数据类型：<code>int</code>、<code>float</code>、<code>double</code>、<code>char</code>、<code>bool</code></li>
<li>复合数据类型：<code>struct</code>、<code>union</code>、<code>enum</code></li>
<li>指针类型：<code>int*</code>、<code>float*</code>、<code>char*</code></li>
<li>引用类型：<code>int&amp;</code>、<code>float&amp;</code>、<code>char&amp;</code></li>
<li>数组类型：<code>int[]</code>、<code>float[]</code>、<code>char[]</code></li>
<li>字符串类型：<code>std::string</code></li>
<li>STL容器类型：<code>std::vector</code>、<code>std::list</code>、<code>std::map</code></li>
<li>自定义数据类型：<code>class</code>、<code>struct</code></li>
<li>基本数据类型的大小：<code>sizeof(int)</code>、<code>sizeof(float)</code>、<code>sizeof(double)</code>、<code>sizeof(char)</code>、<code>sizeof(bool)</code></li>
<li>基本数据类型的范围：<code>INT_MIN</code>、<code>INT_MAX</code>、<code>FLOAT_MIN</code>、<code>FLOAT_MAX</code>、<code>DOUBLE_MIN</code>、<code>DOUBLE_MAX</code></li>
<li>基本数据类型的默认值：<code>int</code>默认为0，<code>float</code>默认为0.0，<code>double</code>默认为0.0，<code>char</code>默认为’\0’，<code>bool</code>默认为false</li>
<li>基本数据类型的初始化：<code>int a = 10;</code>、<code>float b = 3.14;</code>、<code>double c = 2.718;</code>、<code>char d = &#39;A&#39;;</code>、<code>bool e = true;</code></li>
<li>基本数据类型的赋值：<code>a = 20;</code>、<code>b = 2.71;</code>、<code>c = 3.14;</code>、<code>d = &#39;B&#39;;</code>、<code>e = false;</code></li>
<li>基本数据类型的使用：<code>std::cout &lt;&lt; a;</code>、<code>std::cin &gt;&gt; b;</code>、<code>std::cout &lt;&lt; c;</code>、<code>std::cin &gt;&gt; d;</code>、<code>std::cout &lt;&lt; e;</code></li>
<li>基本数据类型的转换：<code>int</code>转<code>float</code>：<code>float f = (float)a;</code>、<code>float</code>转<code>int</code>：&#96;int g &#x3D; (int)b;其他类型转换类似。</li>
</ul>
<h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><h1 id="举个例子说明"><a href="#举个例子说明" class="headerlink" title="举个例子说明"></a>举个例子说明</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> globalVar = <span class="number">10</span>; <span class="comment">// 全局变量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> localVar = <span class="number">20</span>; <span class="comment">// 局部变量</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Local variable: &quot;</span> &lt;&lt; localVar &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Global variable: &quot;</span> &lt;&lt; globalVar &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">function</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Global variable: &quot;</span> &lt;&lt; globalVar &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot;Local variable: &quot; &lt;&lt; localVar &lt;&lt; endl; // 错误，localVar在这里不可见</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>在上面的例子中，<code>globalVar</code>是一个全局变量，可以在整个程序中访问。</li>
<li><code>localVar</code>是一个局部变量，只能在<code>function</code>函数内部访问。</li>
<li>在<code>main</code>函数中，尝试访问<code>localVar</code>会导致编译错误，因为它在<code>main</code>函数的作用域内不可见。</li>
<li>变量的作用域决定了变量在程序中的可见性和生命周期。</li>
<li>全局变量在整个程序中可见，生命周期从程序开始到结束。</li>
<li>局部变量在函数内部可见，生命周期从函数调用开始到函数返回结束。</li>
<li>变量的作用域可以通过使用<code>static</code>关键字来限制，例如：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> staticVar = <span class="number">30</span>; <span class="comment">// 静态全局变量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> staticLocalVar = <span class="number">40</span>; <span class="comment">// 静态局部变量</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Static local variable: &quot;</span> &lt;&lt; staticLocalVar &lt;&lt; endl;</span><br><span class="line">    staticLocalVar++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">function</span>();</span><br><span class="line">    <span class="built_in">function</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Static global variable: &quot;</span> &lt;&lt; staticVar &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在上面的例子中，<code>staticVar</code>是一个静态全局变量，可以在整个程序中访问，但它的值在程序运行期间保持不变。</li>
<li><code>staticLocalVar</code>是一个静态局部变量，它的值在函数调用之间保持不变。</li>
<li>静态变量的生命周期从程序开始到结束，但它的作用域限制在定义它的函数内部。</li>
<li>静态变量的值在函数调用之间保持不变，可以用于保存函数的状态。</li>
<li>静态变量的作用域限制在定义它的函数内部，但它的生命周期从程序开始到结束。</li>
<li>静态变量的优点是可以在函数调用之间保持状态，避免了全局变量的使用。</li>
<li>静态变量的缺点是作用域限制在定义它的函数内部，可能导致代码可读性降低。</li>
<li>静态变量的使用场景：静态变量通常用于保存函数的状态，例如计数器、缓存等。</li>
<li>静态变量的命名规范：静态变量的命名通常使用小写字母和下划线分隔，例如<code>static_var</code>，以便于区分全局变量和静态变量。</li>
<li>静态变量的初始化：静态变量的初始化通常在定义时进行，例如<code>static int staticVar = 0;</code>，也可以在函数内部进行初始化，例如<code>static int staticLocalVar = 0;</code>。</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>vim快捷键</title>
    <url>/2025/04/04/vim%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<h2 id="vim键盘图"><a href="#vim键盘图" class="headerlink" title="vim键盘图"></a>vim键盘图</h2><p><img src="/images/image.jpg" alt="vim键盘图"></p>
<span id="more"></span>
<h3 id="vim快捷键"><a href="#vim快捷键" class="headerlink" title="vim快捷键"></a>vim快捷键</h3><h4 id="如何使用vimv"><a href="#如何使用vimv" class="headerlink" title="如何使用vimv"></a>如何使用vimv</h4><p>在终端中输入<code>vim</code>命令，进入vim编辑器。vim有三种模式：普通模式、插入模式和命令模式。</p>
<ul>
<li>普通模式：默认模式，可以使用各种快捷键进行文本编辑。</li>
<li>插入模式：用于输入文本，可以使用<code>i</code>、<code>a</code>等命令进入。</li>
<li>命令模式：用于执行命令，可以使用<code>:</code>进入。<br>在普通模式下，按<code>i</code>进入插入模式，按<code>Esc</code>返回普通模式。<br>在插入模式下，按<code>Esc</code>返回普通模式，按<code>:</code>进入命令模式。<br>在命令模式下，可以输入各种命令，如保存、退出等。</li>
</ul>
<h4 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h4><p>在命令模式下，可以输入各种命令，如保存、退出等。常用命令如下：</p>
<ul>
<li><code>:w</code>：保存文件</li>
<li><code>:q</code>：退出vim</li>
<li><code>:wq</code>：保存并退出vim</li>
<li><code>:q!</code>：强制退出vim，不保存文件</li>
<li><code>:e filename</code>：打开文件</li>
<li><code>:help</code>：查看帮助文档</li>
</ul>
<h4 id="普通模式"><a href="#普通模式" class="headerlink" title="普通模式"></a>普通模式</h4><p>在普通模式下，可以使用各种快捷键进行文本编辑。常用快捷键如下：</p>
<ul>
<li><code>h</code>：向左移动光标</li>
<li><code>j</code>：向下移动光标</li>
<li><code>k</code>：向上移动光标</li>
<li><code>l</code>：向右移动光标</li>
<li><code>0</code>：移动到行首</li>
<li><code>$</code>：移动到行尾</li>
<li><code>gg</code>：移动到文件开头</li>
<li><code>G</code>：移动到文件结尾</li>
<li><code>x</code>：删除光标所在字符</li>
<li><code>dd</code>：删除光标所在行</li>
<li><code>yy</code>：复制光标所在行</li>
<li><code>P</code>(大写)：粘贴剪切板内容到光标上方</li>
<li><code>p</code>(小写)：粘贴剪切板内容到光标下方</li>
<li><code>u</code>：撤销上一次操作</li>
<li><code>v</code>：进入可视模式，可以选择文本</li>
<li><code>y</code>：复制选中的文本</li>
<li><code>d</code>：删除选中的文本</li>
<li><code>c</code>：剪切选中的文本</li>
<li><code>r</code>：替换光标所在字符</li>
<li><code>.</code>：重复上一个操作</li>
<li><code>Ctrl + r</code>：重做上一个操作</li>
<li><code>:w</code>:保存文件</li>
<li><code>:q</code>:退出vim</li>
<li><code>:wq</code>:保存并退出vim</li>
<li><code>:q!</code>:强制退出vim，不保存文件</li>
</ul>
<h4 id="插入模式"><a href="#插入模式" class="headerlink" title="插入模式"></a>插入模式</h4><p>在插入模式下，可以输入文本。常用快捷键如下：</p>
<ul>
<li><code>i</code>：在光标前插入文本</li>
<li><code>I</code>：在行首插入文本</li>
<li><code>a</code>：在光标后插入文本</li>
<li><code>A</code>：在行尾插入文本</li>
<li><code>o</code>：在光标下方插入新行</li>
<li><code>O</code>：在光标上方插入新行</li>
<li><code>Esc</code>：返回普通模式</li>
</ul>
<h4 id="可视模式"><a href="#可视模式" class="headerlink" title="可视模式"></a>可视模式</h4><p>在可视模式下，可以选择文本。常用快捷键如下：</p>
<ul>
<li><code>v</code>：进入可视模式</li>
<li><code>V</code>：进入行可视模式</li>
<li><code>Ctrl + v</code>：进入块可视模式</li>
<li><code>y</code>：复制选中的文本</li>
<li><code>d</code>：删除选中的文本</li>
<li><code>c</code>：剪切选中的文本</li>
<li><code>p</code>：粘贴</li>
<li><code>u</code>：撤销</li>
</ul>
<h3 id="vim按键说明"><a href="#vim按键说明" class="headerlink" title="vim按键说明"></a>vim按键说明</h3><h4 id="第一部分：一般模式的光标移动，复制粘贴、搜索替换等"><a href="#第一部分：一般模式的光标移动，复制粘贴、搜索替换等" class="headerlink" title="第一部分：一般模式的光标移动，复制粘贴、搜索替换等"></a>第一部分：一般模式的光标移动，复制粘贴、搜索替换等</h4><h4 id="移动光标的方法"><a href="#移动光标的方法" class="headerlink" title="移动光标的方法"></a>移动光标的方法</h4><table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ctrl + f</code></td>
<td>屏幕向下移动一页</td>
</tr>
<tr>
<td><code>ctrl + b</code></td>
<td>屏幕向上移动一页</td>
</tr>
<tr>
<td><code>ctrl + d</code></td>
<td>屏幕向下移动半页</td>
</tr>
<tr>
<td><code>ctrl + u</code></td>
<td>屏幕向上移动半页</td>
</tr>
<tr>
<td><code>n&lt;space&gt;</code></td>
<td>按下数字后再按空格键，光标会向右移动这一行的n个字符。例如20<space>则光标会向后面移动20个字符距离</space></td>
</tr>
<tr>
<td><code>0</code></td>
<td>光标移动到行首</td>
</tr>
<tr>
<td><code>$</code></td>
<td>光标移动到行尾</td>
</tr>
<tr>
<td><code>gg</code></td>
<td>光标移动到文件开头</td>
</tr>
<tr>
<td><code>G</code></td>
<td>光标移动到文件结尾</td>
</tr>
<tr>
<td><code>n&lt;Enter&gt;</code></td>
<td>光标移动到当前行的第n个字符</td>
</tr>
<tr>
<td><code>nG</code></td>
<td>光标移动到第n行</td>
</tr>
</tbody></table>
<h4 id="搜索替换"><a href="#搜索替换" class="headerlink" title="搜索替换"></a>搜索替换</h4><table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>/word</code></td>
<td>向光标之下寻找一个名称为word的字符串。例如要在档案内搜寻vbird这个字符串，就输入&#x2F;vbird即可</td>
</tr>
<tr>
<td><code>?word</code></td>
<td>向光标之上寻找一个名称为word的字符串</td>
</tr>
<tr>
<td><code>n</code></td>
<td>搜寻下一个</td>
</tr>
<tr>
<td><code>N</code></td>
<td>搜寻上一个</td>
</tr>
<tr>
<td><code>:%s/old/new/g</code></td>
<td>将档案内的old字串替换成new字串</td>
</tr>
</tbody></table>
<h4 id="复制、剪切、粘贴"><a href="#复制、剪切、粘贴" class="headerlink" title="复制、剪切、粘贴"></a>复制、剪切、粘贴</h4><table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>x</code></td>
<td>删除光标所在的字符</td>
</tr>
<tr>
<td><code>X</code></td>
<td>删除光标前的字符</td>
</tr>
<tr>
<td><code>dd</code></td>
<td>删除光标所在的行</td>
</tr>
<tr>
<td><code>ndd</code></td>
<td>n为数字。剪切光标所在的向下n行,例如20dd则是剪切20行，用p&#x2F;P可以粘贴</td>
</tr>
<tr>
<td><code>d1G</code></td>
<td>删除光标所在行到第一行的所有数据</td>
</tr>
<tr>
<td><code>dG</code></td>
<td>删除光标所在行到最后一行的所有数据</td>
</tr>
<tr>
<td><code>d0</code></td>
<td>那个是数字的0,删除游标所在处，到该行的最前面的一个字符</td>
</tr>
<tr>
<td><code>yy</code></td>
<td>复制光标所在行</td>
</tr>
<tr>
<td><code>nyy</code></td>
<td>n为数字。复制光标所在行向下n行,例如20yy则是复制20行，用p&#x2F;P可以粘贴</td>
</tr>
<tr>
<td><code>y1G</code></td>
<td>复制光标所在行到第一行的所有数据</td>
</tr>
<tr>
<td><code>yG</code></td>
<td>复制光标所在行到最后一行的所有数据</td>
</tr>
<tr>
<td><code>y0</code></td>
<td>复制光标所在行到该行的最前面的一个字符</td>
</tr>
<tr>
<td><code>y$</code></td>
<td>复制光标所在的那个字符到该行行尾的所有数据</td>
</tr>
<tr>
<td><code>p</code></td>
<td>粘贴到光标后面</td>
</tr>
<tr>
<td><code>P</code></td>
<td>粘贴到光标前面</td>
</tr>
<tr>
<td><code>J</code></td>
<td>将光标所在行与下一行合并</td>
</tr>
<tr>
<td><code>u</code></td>
<td>撤销上一个操作</td>
</tr>
<tr>
<td><code>c</code></td>
<td>重复删除多个数据，例如向下删除10行, [10cj]</td>
</tr>
</tbody></table>
<h4 id="个人快捷键的配置"><a href="#个人快捷键的配置" class="headerlink" title="个人快捷键的配置"></a>个人快捷键的配置</h4><p>我个人的主键是空格<code> </code></p>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;leader&gt;t</code></td>
<td>打开终端</td>
</tr>
<tr>
<td><code>&lt;leader&gt;n</code></td>
<td>打开文件树</td>
</tr>
<tr>
<td><code>&lt;leader&gt;f</code></td>
<td>打开文件树并定位到当前文件</td>
</tr>
<tr>
<td><code>&lt;C-h&gt;</code></td>
<td>切换到左标签页</td>
</tr>
<tr>
<td><code>&lt;C-l&gt;</code></td>
<td>切换到右标签页</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>vim</category>
      </categories>
      <tags>
        <tag>快捷键说明</tag>
      </tags>
  </entry>
  <entry>
    <title>vscode快捷键</title>
    <url>/2025/04/08/vscode%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="工作区快捷键"><a href="#工作区快捷键" class="headerlink" title="工作区快捷键"></a>工作区快捷键</h3><table>
<thead>
<tr>
<th>Linux&#x2F;Windows</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl + Shift + P</td>
<td>打开命令面板</td>
</tr>
<tr>
<td>Ctrl + B</td>
<td>显示&#x2F;隐藏侧边栏</td>
</tr>
<tr>
<td>Ctrl + \</td>
<td>拆分编辑器</td>
</tr>
<tr>
<td>Ctrl + Tab</td>
<td>切换编辑器</td>
</tr>
<tr>
<td>Ctrl + + 、Ctrl + -</td>
<td>放大&#x2F;缩小编辑器</td>
</tr>
<tr>
<td>Ctrl + N</td>
<td>新建文件</td>
</tr>
<tr>
<td>Ctrl + W</td>
<td>关闭当前文件</td>
</tr>
<tr>
<td>Ctrl + &#96;</td>
<td>打开终端</td>
</tr>
</tbody></table>
<h3 id="跳转操作"><a href="#跳转操作" class="headerlink" title="跳转操作"></a>跳转操作</h3><table>
<thead>
<tr>
<th>Linux&#x2F;Windows</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl + PageUp&#x2F;PageDown</td>
<td>在已经打开的多个文件之间进行切换</td>
</tr>
<tr>
<td>Ctrl + Shift + E</td>
<td>显示资源管理器</td>
</tr>
<tr>
<td>Ctrl + Shift + F</td>
<td>显示搜索</td>
</tr>
<tr>
<td>Ctrl + shift + O</td>
<td>在当前文件的各种方法之间进行跳转</td>
</tr>
<tr>
<td>Ctrl + G</td>
<td>跳转到指定行</td>
</tr>
<tr>
<td>Ctrl + Shift + \</td>
<td>跳转到匹配的括号</td>
</tr>
</tbody></table>
<h3 id="编辑操作"><a href="#编辑操作" class="headerlink" title="编辑操作"></a>编辑操作</h3><table>
<thead>
<tr>
<th>Linux&#x2F;Windows</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl + Enter</td>
<td>在当前行的下方新增一行，然后跳转至该行</td>
</tr>
<tr>
<td>Ctrl + Shift + Enter</td>
<td>在当前行的上方新增一行，然后跳转至该行</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>vscode</category>
      </categories>
      <tags>
        <tag>快捷键说明</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么悬垂指针在rust里是不安全的</title>
    <url>/2025/04/10/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%82%AC%E5%9E%82%E6%8C%87%E9%92%88%E5%9C%A8rust%E9%87%8C%E6%98%AF%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84/</url>
    <content><![CDATA[<p>在 Rust 中，<strong>悬垂引用（Dangling Reference）</strong> 是一种严重的内存安全问题，因为它会导致程序访问已释放或无效的内存，从而引发未定义行为（Undefined Behavior, UB）。Rust 的所有权系统和借用检查器（Borrow Checker）的核心目标之一就是<strong>在编译时彻底杜绝悬垂引用</strong>。以下是详细解释：</p>
<hr>
<h3 id="1-什么是悬垂引用？"><a href="#1-什么是悬垂引用？" class="headerlink" title="1. 什么是悬垂引用？"></a>1. <strong>什么是悬垂引用？</strong></h3><p>悬垂引用是指一个指针或引用指向的内存地址<strong>已被释放或不再有效</strong>，但程序仍尝试通过该引用访问数据。例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">dangling_reference</span>() <span class="punctuation">-&gt;</span> &amp;<span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>); <span class="comment">// `s` 在函数结束时被销毁</span></span><br><span class="line">    &amp;s <span class="comment">// 返回一个指向已释放内存的引用（编译错误！）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Rust 编译器会直接拒绝此类代码，因为 <code>s</code> 的生命周期仅限于函数内部，而返回的引用会超出其生命周期。</p>
<span id="more"></span>
<hr>
<h3 id="2-为什么悬垂引用危险？"><a href="#2-为什么悬垂引用危险？" class="headerlink" title="2. 为什么悬垂引用危险？"></a>2. <strong>为什么悬垂引用危险？</strong></h3><ul>
<li><strong>未定义行为（UB）</strong>：访问已释放的内存可能导致程序崩溃、数据损坏或安全漏洞（如攻击者利用悬垂指针注入恶意代码）。</li>
<li><strong>难以调试</strong>：悬垂引用的问题可能在运行时随机出现，且难以复现（取决于内存分配器的行为）。</li>
</ul>
<hr>
<h3 id="3-Rust-如何防止悬垂引用？"><a href="#3-Rust-如何防止悬垂引用？" class="headerlink" title="3. Rust 如何防止悬垂引用？"></a>3. <strong>Rust 如何防止悬垂引用？</strong></h3><p>Rust 通过以下机制在编译时静态检查所有引用的有效性：</p>
<h4 id="（1）生命周期标注（Lifetimes）"><a href="#（1）生命周期标注（Lifetimes）" class="headerlink" title="（1）生命周期标注（Lifetimes）"></a>（1）<strong>生命周期标注（Lifetimes）</strong></h4><ul>
<li>显式或隐式标注引用的生命周期，确保引用不会比其引用的数据存活更久。</li>
<li>示例：<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>&lt;<span class="symbol">&#x27;a</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, y: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.<span class="title function_ invoke__">len</span>() &gt; y.<span class="title function_ invoke__">len</span>() &#123; x &#125; <span class="keyword">else</span> &#123; y &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
编译器会确保返回的引用 <code>&amp;&#39;a str</code> 不会超过输入参数的生命周期。</li>
</ul>
<h4 id="（2）所有权规则"><a href="#（2）所有权规则" class="headerlink" title="（2）所有权规则"></a>（2）<strong>所有权规则</strong></h4><ul>
<li>数据的所有者（Owner）负责释放内存，引用（Borrow）必须遵守所有权的生命周期。</li>
<li>任何试图返回悬垂引用的代码都会被编译器拒绝：<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">invalid</span>() <span class="punctuation">-&gt;</span> &amp;<span class="type">i32</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">42</span>;</span><br><span class="line">    &amp;x <span class="comment">// 错误！`x` 的生命周期不足</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="（3）借用检查器（Borrow-Checker）"><a href="#（3）借用检查器（Borrow-Checker）" class="headerlink" title="（3）借用检查器（Borrow Checker）"></a>（3）<strong>借用检查器（Borrow Checker）</strong></h4><ul>
<li>在编译时分析所有引用的作用域，确保：<ul>
<li>引用不会比其引用的数据存活更久。</li>
<li>不存在数据竞争（通过 <code>可变引用独占性</code> 规则）。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="4-对比其他语言"><a href="#4-对比其他语言" class="headerlink" title="4. 对比其他语言"></a>4. <strong>对比其他语言</strong></h3><ul>
<li><strong>C&#x2F;C++</strong>：允许悬垂指针，需程序员手动保证安全（极易出错）。</li>
<li><strong>Java&#x2F;Python</strong>：通过垃圾回收（GC）避免悬垂引用，但牺牲性能和实时性。</li>
<li><strong>Rust</strong>：<strong>零成本抽象</strong>，无需运行时 GC，完全在编译期解决问题。</li>
</ul>
<hr>
<h3 id="5-如何避免悬垂引用？"><a href="#5-如何避免悬垂引用？" class="headerlink" title="5. 如何避免悬垂引用？"></a>5. <strong>如何避免悬垂引用？</strong></h3><ul>
<li><strong>遵循所有权规则</strong>：确保引用的作用域不超过被引用数据。</li>
<li><strong>使用生命周期参数</strong>：在函数或结构体中显式标注生命周期。</li>
<li><strong>必要时转移所有权</strong>：返回数据本身而非引用（如返回 <code>String</code> 而非 <code>&amp;String</code>）。</li>
</ul>
<hr>
<h3 id="示例：安全的替代方案"><a href="#示例：安全的替代方案" class="headerlink" title="示例：安全的替代方案"></a>示例：安全的替代方案</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">no_dangle</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123; <span class="comment">// 返回所有权而非引用</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    s <span class="comment">// 转移所有权到调用者</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>内存安全</tag>
        <tag>悬垂引用</tag>
        <tag>生命周期</tag>
      </tags>
  </entry>
  <entry>
    <title>如何书写规范的Git Commit</title>
    <url>/2025/04/15/%E5%A6%82%E4%BD%95%E4%B9%A6%E5%86%99%E8%A7%84%E8%8C%83%E7%9A%84Git-Commit/</url>
    <content><![CDATA[<p>编写规范的 Git Commit 信息是团队协作和项目管理的重要实践，它能让代码历史清晰可读，方便回溯问题、生成变更日志，甚至自动化版本管理。但令绝大多数人头疼的是，Git Commit 信息的规范并没有一个统一的标准。不同的团队、项目和个人都有自己的习惯和风格。<br>在这里，我将介绍一些常见的 Git Commit 信息规范和最佳实践，帮助你编写出更清晰、更易读的 Commit 信息。</p>
<span id="more"></span>

<h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><p>规范的提交信息通常分为 标题（Subject）、正文（Body） 和 结尾（Footer）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;类型&gt;(&lt;作用域&gt;): &lt;主题&gt;</span><br><span class="line">&lt;空行&gt;</span><br><span class="line">&lt;正文&gt;</span><br><span class="line">&lt;空行&gt;</span><br><span class="line">&lt;结尾&gt;</span><br></pre></td></tr></table></figure>

<h2 id="核心要素"><a href="#核心要素" class="headerlink" title="核心要素"></a>核心要素</h2><p><strong>（1）类型（Type）</strong></p>
<ul>
<li>feat: 新增功能（feature）</li>
<li>fix: 修复问题（bug fix）</li>
<li>docs: 文档更新（documentation）</li>
<li>style: 代码格式调整（不影响逻辑，如空格、分号）</li>
<li>refactor: 重构代码（非功能新增，也非问题修复）</li>
<li>test: 测试相关（新增或修改测试用例）</li>
<li>chore: 构建&#x2F;工具&#x2F;配置等杂项更新</li>
<li>perf: 性能优化</li>
<li>ci: 持续集成相关（如 GitHub Actions）</li>
<li>build: 构建系统或依赖变更（如 npm、Maven）</li>
<li>revert: 回滚某次提交</li>
</ul>
<p><strong>（2） 主题（Subject）</strong></p>
<ul>
<li>简洁清晰：控制在 50 字符以内，描述“做了什么”。</li>
<li>使用祈使语气：如“Add”而非“Added”或“Adds”。</li>
<li>首字母小写，结尾不加句号。</li>
<li>可选作用域：说明影响范围（如模块、组件），例如 <code>fix(login):</code></li>
</ul>
<p>示例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">feat(auth): add OAuth2 login support</span><br><span class="line">fix(api): handle null response in user endpoint</span><br></pre></td></tr></table></figure>

<p><strong>（3）正文（Body）（非必需，但复杂变更需补充）</strong></p>
<ul>
<li>解释“为什么”修改：动机、背景、与之前行为的对比。</li>
<li>每行不超过 72 字符，段落用空行分隔。</li>
<li>使用列表（- 或 *）或代码块（&#96;&#96;&#96;）提升可读性。</li>
</ul>
<p>示例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- Replace deprecated API `getUserInfo` with `fetchUserProfile`.</span><br><span class="line">- Add error logging for failed authentication attempts.</span><br></pre></td></tr></table></figure>

<p><strong>（4）结尾（Footer）（非必需）</strong></p>
<ul>
<li>关联 Issue：如 Closes #123、Fixes JIRA-456。</li>
<li>重大变更（BREAKING CHANGE）：标明不兼容的改动，说明迁移方法。</li>
</ul>
<p>示例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BREAKING CHANGE: Remove support for legacy API v1.</span><br><span class="line">Migration guide: https://example.com/migration/v2</span><br><span class="line">Closes #45</span><br></pre></td></tr></table></figure>

<h2 id="优秀示例"><a href="#优秀示例" class="headerlink" title="优秀示例"></a>优秀示例</h2><p><strong>简单修复：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fix: prevent infinite loop in data parser</span><br></pre></td></tr></table></figure>
<p><strong>复杂功能：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">feat(payment): integrate Stripe API</span><br><span class="line"></span><br><span class="line">- Add Stripe SDK dependency</span><br><span class="line">- Implement payment intent creation</span><br><span class="line">- Handle webhook events for failed charges</span><br><span class="line"></span><br><span class="line">Closes #102</span><br><span class="line">BREAKING CHANGE: Remove PayPal support due to API deprecation.</span><br></pre></td></tr></table></figure>

<h2 id="避免常见错误"><a href="#避免常见错误" class="headerlink" title="避免常见错误"></a>避免常见错误</h2><ul>
<li><p>❌ 模糊描述：<code>Update file.js</code> → ✅ <code>fix: resolve image upload timeout</code></p>
</li>
<li><p>❌ 冗长标题：<code>Change the way we handle errors in...</code>（超过 50 字符）</p>
</li>
<li><p>❌ 忽略正文：未说明为何重构代码或修复逻辑。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Git</category>
        <category>编程规范</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>所有权和借用</title>
    <url>/2025/04/10/%E6%89%80%E6%9C%89%E6%9D%83%E5%92%8C%E5%80%9F%E7%94%A8/</url>
    <content><![CDATA[<h1 id="Rust的所有权和借用"><a href="#Rust的所有权和借用" class="headerlink" title="Rust的所有权和借用"></a>Rust的所有权和借用</h1><p>内存回收是编程语言设计的重点之一，如今的计算机语言中，关于内存回收的机制出现三种流派：</p>
<ul>
<li>垃圾回收机制 （Garbage Collection），在程序运行时自动回收不再使用的内存。</li>
<li>手动管理内存的分配和释放，在程序中，通过函数调用的方式申请和释放内存。</li>
<li>通过所有权来管理内存的分配和释放，Rust就是这种语言。</li>
</ul>
<p><strong>一段不安全的代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    a = <span class="number">100</span>;</span><br><span class="line">    <span class="type">char</span> *c = <span class="string">&quot;xyz&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> &amp;a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码中，a是局部变量，当函数结束后将局部变量a的地址返回，a存在栈中，在离开作用域后，a所申请的栈上内存会被系统回收，从而造成了悬空指针的错误。这是一个非常典型的内存安全的问题。虽然编译可以通过，但是运行的时候会出现错误。<br>再来看变量c，c的值是常量字符串，存储于常量区，我们可能只用一次，但必须”xyz”只有当整个程序结束后才会回收这片内存。</p>
<span id="more"></span>
<h2 id="栈和堆"><a href="#栈和堆" class="headerlink" title="栈和堆"></a>栈和堆</h2><p>对于大小为止或可能变换的数据，我们需要存储在堆上。当向堆上放入数据时，需要请求一定大小的内存空间。操作系统在堆的某处找到一块足够大的空位，把它标记为已使用，并返回一个表示该位置地址的指针，该过程被称为在堆上分配内存，有时简称为 “分配”(allocating)。</p>
<p>接着，该指针会被推入栈中，因为指针的大小是已知且固定的，在后续使用过程中，你将通过栈中的指针，来获取数据在堆上的实际内存位置，进而访问该数据。</p>
<p><strong>所有权原则</strong></p>
<ul>
<li>Rust 中每一个值都被一个变量所拥有，该变量被称为值的所有者</li>
<li>一个值同时只能被一个变量所拥有，或者说一个值只能拥有一个所有者</li>
<li>当所有者（变量）离开作用域范围时，这个值将被丢弃(drop)</li>
</ul>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>语音信号处理杂谈</title>
    <url>/2025/04/22/%E8%AF%AD%E9%9F%B3%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E6%9D%82%E8%B0%88/</url>
    <content><![CDATA[<p>语音其实是人类采集的声音的幅度强度随着时间变化的一系列点。如下图为汉语元音韵母 “a”的声音波形图的一部分。<br><img src="/images/image.png" alt="波形图"><br>上图中横坐标表示时间，纵坐标表示声音的幅度强度。可以看到，声音的幅度强度随着时间变化而变化。我们可以把声音看成是一个个点组成的波形图。声音的波形图是一个连续的函数，实际上是一个离散的函数。我们可以把它看成是一个个点组成的波形图。声音的波形图是一个连续的函数，实际上是一个离散的函数。我们可以把它看成是一个个点组成的波形图。声音的波形图是一个连续的函数，实际上是一个离散的函数。我们可以把它看成是一个个点组成的波形图。<span id="more"></span><br>这里就涉及到一个信号处理的基本概念:采样频率。关于采样定理可以参考<a href="https://www.zhihu.com/question/24490634">采样定理</a>。</p>
<p>我们来举个具体的例子来体会一下如何理解语音的采样点和时长。<br>例如有一个语音，某个录音机器以 16000个点&#x2F;秒的速度（采样率）去测试这个声音， 测了2s，我们则会得到 2 * 16000 &#x3D; 32000个采样点。 也就是说，实际在图片里看到的曲线虽然是连续的曲线，但是实际上是由 离散的 有间隔的 点组成的。<br>因此我们得出一个 公式： 采样率 * 语音时长 &#x3D; 语音采样点数。<br>同样的采样率的情况下，语音的采样点数越多，就会导致语音文件的大小越大。</p>
<h1 id="语音信号处理基本流程"><a href="#语音信号处理基本流程" class="headerlink" title="语音信号处理基本流程"></a>语音信号处理基本流程</h1><p><img src="/images/audio_process.png" alt="语言信号处理基本流程图"><br>上图是一个语音信号处理的基本流程图。我们来逐一分析一下。</p>
<h2 id="分帧"><a href="#分帧" class="headerlink" title="分帧"></a>分帧</h2><p>可能有人会有疑问，我们为什么要做分帧操作，直接处理一整条波形图不是更方便吗？我想说：还真不是。</p>
<ul>
<li><strong>1.分帧操作是处理非平稳信号的必然选择</strong><br>自然界中的信号（如语音、音乐）大多是 非平稳信号：其频率成分随时间变化（例如说话时的元音、辅音切换，音乐中的旋律起伏）。傅里叶变换（DFT&#x2F;FFT）要求信号是 <strong>平稳信号</strong>（统计特性不随时间变化），否则频谱分析结果会失去物理意义（无法反映某一时刻的频率成分）。为了能够用傅里叶变换，我们将长信号分割成短时段的 “帧”（Frame），假设每一帧内的信号是 “短时平稳” 的（窗长通常为 10-50ms，语音信号的基音周期约为 5-20ms，确保帧内信号特性变化足够小）。分帧的本质是将非平稳信号转化为多个短时平稳信号的序列，使每个帧可以单独进行傅里叶变换，从而得到随时间变化的频谱（即频谱图，Spectrogram）。</li>
<li><strong>2.时域分析与频域分析的平衡</strong><br>若不分帧（直接对整个长信号做傅里叶变换），虽然能得到全局频谱，但丢失了频率成分随时间变化的信息（例如无法区分 “先弹钢琴后弹吉他” 的信号）。分帧后，每个短帧的时长（窗长）决定了时间分辨率和频率分辨率（如前所述：窗长越短，时间分辨率越高，频率分辨率越低），需根据信号特性选择合适的窗长（如语音分析常用 25ms 窗长，兼顾音高和共振峰的时变特性）。</li>
</ul>
<h3 id="分帧参数"><a href="#分帧参数" class="headerlink" title="分帧参数"></a>分帧参数</h3><ul>
<li><strong>帧长:(hop size &#x2F; hop length)</strong>：每帧的时长，通常为 20-30ms（如 25ms），需根据信号特性选择。</li>
<li><strong>帧移</strong>：相邻帧之间的时间间隔，通常为 50% 帧长（如 10ms），可根据需要调整。</li>
<li><strong>窗函数</strong>：用于加窗操作的函数（如汉明窗、汉宁窗），可减少频谱泄漏现象，提高频谱分析精度。</li>
<li><strong>窗函数长度: window size &#x2F; window length</strong>：窗函数的长度通常与帧长相同（如 25ms或者1024个采样点），但也可根据需要调整。</li>
<li><strong>窗函数类型</strong>：常用的窗函数有矩形窗、汉明窗、汉宁窗、布莱克曼窗等。不同窗函数对频谱泄漏和旁瓣抑制的效果不同，需根据具体应用选择合适的窗函数。</li>
<li><strong>帧数</strong>: 计算公式：语音信号长度 &#x2F;&#x2F; hop_length + 1 &#x3D; 帧数</li>
</ul>
<p>关于分帧，可以参考<a href="hhttps://www.zhihu.com/question/52093104">分帧</a>。</p>
<h2 id="加窗"><a href="#加窗" class="headerlink" title="加窗"></a>加窗</h2><p>加窗是对每一帧信号进行加窗操作，目的是为了减少频谱泄漏现象，提高频谱分析精度。加窗的过程是将每一帧信号乘以一个窗函数（如汉明窗、汉宁窗等），使得每一帧信号在时间上有一个平滑的过渡。通过使用 <strong>平滑窗函数</strong>（如汉宁窗、汉明窗），让信号在帧的边缘逐渐衰减到零，而非突然截断。这样，信号在帧内的幅值从起点到终点平滑过渡（起点和终点幅值接近零），减少了时域的不连续性，从而降低频域旁瓣的能量（旁瓣幅值衰减更快，泄漏减少）。</p>
<h2 id="预加重-可选"><a href="#预加重-可选" class="headerlink" title="预加重(可选)"></a>预加重(可选)</h2><p>预加重是对每一帧信号进行预加重操作，目的是为了提高高频成分的能量，提高频谱分析精度。预加重的过程是将每一帧信号乘以一个预加重系数（如 0.97），使得每一帧信号在时间上有一个平滑的过渡。通过使用 <strong>预加重</strong>，让信号在帧的边缘逐渐衰减到零，而非突然截断。这样，信号在帧内的幅值从起点到终点平滑过渡（起点和终点幅值接近零），减少了时域的不连续性，从而降低频域旁瓣的能量（旁瓣幅值衰减更快，泄漏减少）。</p>
<h2 id="FFT-快速傅里叶变换"><a href="#FFT-快速傅里叶变换" class="headerlink" title="FFT(快速傅里叶变换)"></a>FFT(快速傅里叶变换)</h2><p>波形图经过 <strong>分帧（Framing）</strong> 和<strong>加窗（Windowing）</strong> 处理后，得到的是 加窗后的短时信号片段（短时帧序列）,然后</p>
]]></content>
      <categories>
        <category>语音信号处理</category>
      </categories>
      <tags>
        <tag>语音信号处理</tag>
      </tags>
  </entry>
</search>
